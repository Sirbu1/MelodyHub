# 已解决问题和解决方法

本文档记录了项目中已发现并解决的问题，以及对应的解决方案。

### 1. 登出时Token处理问题
**问题描述**:
登出时，前端可能传入带有"Bearer "前缀的token，或者token可能已失效无法解析，导致登出失败或抛出异常。

**位置**: `UserServiceImpl.java:465-495`

**解决方法**:
```java
@Override
@CacheEvict(cacheNames = {"userCache", "userFavoriteCache", "songCache", "artistCache", "playlistCache"}, allEntries = true)
public Result logout(String token) {
    // 尝试从token中提取实际的token值（去掉Bearer前缀）
    String actualToken = token;
    if (token != null && token.startsWith("Bearer ")) {
        actualToken = token.substring(7);
    }
    
    // 注销token（如果token存在则删除，不存在也视为成功，因为用户已经登出）
    try {
        // 先尝试从token中解析userId
        try {
            Map<String, Object> claims = JwtUtil.parseToken(actualToken);
            Object userIdObj = claims.get(JwtClaimsConstant.USER_ID);
            if (userIdObj != null) {
                Long userId = TypeConversionUtil.toLong(userIdObj);
                // 删除userId到token的映射
                stringRedisTemplate.delete("user:token:" + userId);
            }
        } catch (Exception e) {
            // 如果解析失败，继续删除token本身
            log.warn("解析token失败，继续删除token: " + e.getMessage());
        }
        
        // 删除token本身
        stringRedisTemplate.delete(actualToken);
        // 无论删除是否成功，都返回成功，因为用户已经登出
        return Result.success(MessageConstant.LOGOUT + MessageConstant.SUCCESS);
    } catch (Exception e) {
        // 即使删除失败，也返回成功，因为用户已经登出
        return Result.success(MessageConstant.LOGOUT + MessageConstant.SUCCESS);
    }
}
```

**效果**: 解决了token格式不一致和失效token导致的登出异常问题，确保登出操作始终能够成功执行。


### 2. 公开路径的Token验证处理

**问题描述**:
公开路径（如歌单详情、歌曲详情等）在token失效时也应该允许访问，但之前的逻辑可能导致无法正常访问。

**位置**: `LoginInterceptor.java:117-133`

**解决方法**:
```java
// 从redis中获取相同的token
ValueOperations<String, String> operations = stringRedisTemplate.opsForValue();
String redisToken = operations.get(token);
if (redisToken == null) {
    // token失效，如果是公开路径，仍然允许访问
    if (isAllowedPath || isPublicPath) {
        return true;
    }
    throw new RuntimeException();
}

// ... 解析token ...

// 如果是公开路径，直接设置ThreadLocal并放行
if (isAllowedPath || isPublicPath) {
    ThreadLocalUtil.set(claims);
    return true;
}
```

**效果**: 确保公开路径即使token失效也能正常访问，同时对于需要登录的路径仍然进行验证。



### 3. ThreadLocal内存泄漏防护

**问题描述**:
ThreadLocal中的数据如果没有及时清理，可能导致内存泄漏。

**位置**: `ThreadLocalUtil.java` 和 `LoginInterceptor.java:154-158`

**解决方法**:
```java
@Override
public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
    // 清空ThreadLocal中的数据
    ThreadLocalUtil.remove();
}
```

**效果**: 确保了ThreadLocal中的数据在请求结束后被及时清理，防止内存泄漏。

---

### 4. 用户收藏重复插入问题

**问题描述**:
在并发场景下，用户可能同时多次点击收藏按钮，导致重复插入收藏记录，引发数据库唯一约束冲突异常。

**位置**: `UserFavoriteServiceImpl.java:111-128`

**解决方法**:
```java
@Override
@CacheEvict(cacheNames = {"userFavoriteCache", "songCache", "artistCache", "playlistCache"}, allEntries = true)
public Result collectSong(Long songId) {
    Map<String, Object> map = ThreadLocalUtil.get();
    Object userIdObj = map.get(JwtClaimsConstant.USER_ID);
    Long userId = TypeConversionUtil.toLong(userIdObj);

    // 先检查是否已收藏（防止重复插入）
    QueryWrapper<UserFavorite> queryWrapper = new QueryWrapper<>();
    queryWrapper.eq("user_id", userId).eq("type", 0).eq("song_id", songId);
    if (userFavoriteMapper.selectCount(queryWrapper) > 0) {
        return Result.error("该歌曲已在收藏列表中");
    }

    // 插入收藏记录
    UserFavorite userFavorite = new UserFavorite();
    userFavorite.setUserId(userId).setType(0).setSongId(songId).setCreateTime(LocalDateTime.now());
    try {
        userFavoriteMapper.insert(userFavorite);
    } catch (Exception e) {
        // 如果因为唯一约束冲突导致插入失败，说明已存在（可能是并发情况）
        if (e.getMessage() != null && e.getMessage().contains("Duplicate entry")) {
            return Result.error("该歌曲已在收藏列表中");
        }
        throw e; // 其他异常继续抛出
    }
    // ... 后续逻辑
}
```

**效果**: 通过先查询再插入的方式，结合异常捕获处理并发情况，有效防止了重复收藏的问题，提供了友好的错误提示。


### 5. JWT密钥硬编码
**位置**: `vibe-music-server/src/main/java/cn/edu/seig/vibemusic/util/JwtUtil.java:15`

**问题描述**:
```java
private static final String SECRET_KEY = "VIBE_MUSIC"; // 更改为你的密钥
```
JWT密钥硬编码在代码中，存在严重安全风险。如果代码泄露，攻击者可以伪造任意JWT令牌。

**解决**:- 将密钥移到配置文件（如`application.yml`）中


### 6. 添加输入验证和清理
**建议**: 对所有用户输入进行验证和清理，防止XSS、SQL注入等攻击

使用了MyBatis可以使用 #{} 占位符防止SQL注入

